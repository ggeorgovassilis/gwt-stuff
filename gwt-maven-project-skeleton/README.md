gwt-maven-project-skeleton
==========================

# Overview

A basic GWT and Maven 3 project which can serve as a base for quickly bootstrapping enterprise applications. The project doesn't follow 'best practices' everywhere  simply because after having completed several GWT projects it turns out that in practice many of them are counter productive. Good things you'll find here:

* MVP
* Event bus
* Handling browser history
* RPC
* Maven
* Spring

Anti-patterns (aka 'Best practices') you won't find here:

* Activities
* UI binder
* Request factory
* 100% annotations
* Programmatic, swing-like UI construction

Features:

* A GWT and Spring demonstration web application
* Full Maven 3 lifecycle 
* GWT 2.6
* Spring 3.2
* Unit tests for Spring backend
* Unit tests for GWT frontend 
* Purposefully committed Eclipse project settings to demonstrate useful deployment assembly

To do:

* Integration tests with embedded servlet container
* Automated frontend tests
* Expand on the documentation

# Methodology and tools

The instructions refer to GWT 2.6.1. The project uses maven and the gwt-maven-plugin.

## What do I do?

```mvn clean install```

## How do I get started with super dev mode?

There's an initial setup. You do this only once for every project.

1. Deploy the WAR to a servlet container. We'll assume it runs under http://localhost:8080/gwt-maven-project-skeleton/
2. run ```mvn gwt:run-codeserver```
3. Visit http://localhost:8888/
4. Bookmark the two buttons following the instructions
5. Visit http://localhost:8080/gwt-maven-project-skeleton/
6. Click on Dev Mode on
7. Bookmark the Compile button

That's it. Now, the next day when you start your computer you only have to do these steps:

1. Start the servlet container
2. run ```mvn gwt:run-codeserver```
3. http://localhost:8080/gwt-maven-project-skeleton/
4. Any time you make a change to client code, just click on the bookmarked Compile button and the browser will reload the application with changes

# Demo application architecture

## Overview

The demo application is a very simple contact list editor with a Spring backend and a GWT frontend.

## Backend

 The data model is a bunch of JPA entities in the ```server.backend.domain``` package.
Persistence is handled with spring-data-jpa DAOs in the ```server.backend.daos``` package.
The model is rather simple: a ```Contact``` has a few flat properties and a list of ```Address``` relations.

Note that the JPA model is used internally by the backend. As in every proper enterprise application, the persistence model is not exposed directly to clients,
instead we're using DTOs in the ```common.domain``` package. This involves some duplication, but gives the application more control over what and when to expose.
For instance, when viewing the initial list of contacts, you wouldn't want to get a full list with every contact detail and every address. That particular service call returns a slim version of a contact called ```PersonalDetailsDTO``` which doesn't include addresses.

The DTO is similar to the domain model, but with a twist:

```java 
class ContactDTO{
	PersonalDetailsDTO details;
	List<AddressDTO> addresses;
}```

A little counter-intuitively, the contact's ID is hidden in ```ContactDTO.details.ID```, but that avoids duplication of the ID into ```ContactDTO``` and allows us to reuse the ```PersonalDetailsDTO`` wherever we need to operate only on the contact and not its addresses.


The ```web.xml``` defines 
The backend code resides in the ```server.* ``` sub-package consisting of Spring data DAOs and an ```AddressBookService``` which is exposed as an
RPC service to GWT via the [GWT-SL](https://github.com/ggeorgovassilis/gwt-sl). The web-agnostic part of the application is defined in ```application-context.xml``` and the web specific part in ```api-servlet.xml```.

Business logic is defined in ```AddressBookServiceImpl```. The beauty of spring-data-jpa and the GWT-SL lies in that the service implementation does not require any dependencies on ORMs, JDBC or the servlet API, not even the GWT API.

## Frontend

The frontend consists purely of static HTML and javascript generated by the GWT compiler. As a true single page application, the only HTML page is generated by ```index.jsp``` which loads the javascript output of the GWT compiler. The client then communicates with the backend ```AddressBookService``` in order to query and update contacts.

The demo application uses two notable techniques:

### Templating

GWT advocates programming the UI either via the UI binder or programmatically. I have found both techniques to be problematic and slow; instead I'm demonstrating a technique I call 'templating'. The gist is to define your UI forms as a normal part of the HTML like this:

```html

<div id="edit-contact-form" class="page">
<h1>Edit contacts</h1>
Your name: <input id="name" type="text"/>
<button id="save-contact-button">Save</button>
</div>
```
and then access it with widgets:

```java
class EditContactForm extends Composite{

HTMLPanel panel;
TextBox name;
Button saveButton;

public EditContactForm(Element e){
	constructUI();
	panel = HTMLPanel.wrap(e);
	initWidget(panel);
	onAttach();
}

protected void constructUI(){
	name = TextBox.wrap(DOM.getElementById("name"));
	saveButton = Button.wrap(DOM.getElementById("save-contact-button"));	
}

//...
}

```

Note that there are some caveats with this technique when involving nested widgets: GWT won't allow creating child widgets once the parent has been attached, that's why we split the UI construction in the constructor into a different method which extending widgets can override. Since wrapping the element directly in the constructor makes the form 'live', without it having been added to any other widget, we need to call the ```onAttach()`` method to have it start receiving events. 

### MVP

MVP really does not need any introduction; it's the prominent technique used to structure large GWT applications. The demo uses the following view-presenter pairs:

```ContactListView``` and ```ContactListViewPresenter``` which handle a list of contacts
```EditContactView``` and ```EditContactViewPresenter``` which handle existing contacts, creating new contacts and editing their details.
```AddressListView``` and ```AddressListViewPresenter``` which handle a contact's addresses.

Note that the latter two views and presenters contain some nesting, which demonstrates nicely how views delegate control to presenters. Presenters also react to events broadcast by other presenters or backend services.

### Handling transitions between views

Each view is strictly responsible for a particular step in the use case. When a view passes control to a different view, it does so via the ```Transitions``` class
which also handles browser history.

### Error handling

Coming soon

### Communicating with the backend

Backend communication is abstracted in the ```AddressBookServiceFacade```. The client will invoke a method on the facade, which will then asynchronously contact the server. Once the server replies, it will cast an event which is processed by one or more presenters.